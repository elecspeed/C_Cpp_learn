#define _CRT_SECURE_NO_WARNINGS 1

//编程环境
//预处理


#include <stdio.h>

// 编程的翻译环境 和 运行环境

/*
 * C 标准的任何一种实现中，存在两个不同的环境：
 * 翻译环境和运行环境
 * 
 * test.c 源文件经过 预处理、编译、汇编和链接 生成可执行程序 test.exe，
 * 这个过程中所依赖的环境，称为翻译环境。
 * （通常也把预处理、编译、汇编三个过程合在一起，简称编译）
 * 
 * 从本质上看，源文件属于文本文件，而可执行文件则是二进制文件。
 * 从源文件到可执行文件，其实就是把人看得懂的文本文件，
 * 翻译成计算机能执行的二进制文件。
 * 
 * 至于生成的可执行文件如何运行，就要依赖具体计算机的运行环境了。
 * 不同计算机的实现原理都是一样的，都有运算器、存储器等等，
 * 但实现的方式却各有不同，不同的实现对应不同的程序运行环境。
 */

// 我们现在来研究翻译环境，观察源代码是如何转换为可执行的机器指令的。
// 

// 运行第一个程序之前，打开 file explorer 观察目录底下的文件
// 运行后，再观察目录，会发现底下多了一些文件
// （我的翻译环境为，OS: win11、编辑器：VS、编译器：MSVC）
//

// 简单 C 程序
//#define SIZE 10
//int gral = 100;
//int main()
//{
//    int arr[SIZE] = { 0 };
//    int i = 0;
//    for (i = 0; i < SIZE; i++)
//        arr[i] = i;
//
//    for (i = 0; i < SIZE; i++)
//        printf("%d ", arr[i]);
//
//    return 0;
//}

// 原本只有 test.c 和一些配置文件，
// 运行后有了 test.exe、test.obj 以及一些杂项文件。
// 这些配置文件和杂项文件不是关键的文件，大部分只是 VS 特有的。
// 我们只研究 test.obj。
// 问题来了，test.obj 究竟是什么，为什么要有这个文件？
//

/*
 * C/C++ 语言中有一个重要思想――分别编译，
 * 指的是若干个源文件可以在不同的时候分别编译，在合适的时候整合在一起。
 * 
 * 比如有三个源文件 main.c、A.c 和 B.c，
 * main.c 是 main 函数所在的文件，A.c 可以实现文件删除的功能，B.c 可以文件找回。
 * 实际开发过程中，编程人员先将 A.c 与 main.c 分别编译、整合，
 * 把生成的 APP 交付给用户使用；
 * 然后根据用户的反馈――说 APP 文件删除后不能回复，希望能改进――
 * 再编译 B.c，把编译得到的 B.obj 与 A.obj、main.obj 一起，整合成新版本的 APP。
 * 
 * 所以，拓展名为 .obj 的文件，其实就是源文件编译后得到的，称为目标文件（object file）。
 * 其中，把目标文件整合成可执行文件，由链接器来完成。
 */

// 现在我们知道了，从源文件到程序经过四步：预处理、编译、汇编、链接。
// 下面具体来看每一步都干了什么。
// （因为 VS 在生成可执行文件时，看不到预处理和编译的结果，就不敲代码了）
// （可以在 Linux 环境下观察）
//

/*
 * 预处理器干的其实就一件事：文本操作。具体来说有
 * 1.头文件的包含   2.用空格替换注释   3.宏替换   ...
 * 
 * 编译器干的是核心工作：把 C 代码翻译成汇编代码。具体来说有
 * 1.词法分析   2.语法分析   3.语义分析   4.符号汇总   ...
 * （详见《编译原理》）
 * 
 * 汇编器干的是，把汇编代码翻译成二进制机器指令，并形成符号表。
 * 
 * 链接器干的是：
 * 1.合并段表   2.符号表的合并与重定位
 * 简单来说就是，根据得到的符号表，
 * 把汇编得到的若干个目标文件与必要的库文件一起，整合成可执行文件。
 */

// 程序执行的过程
//

/*
 * 程序执行前必须放到内存中。
 * 该操作一般由操作系统完成；如果没有操作系统，则手动安排。
 * 
 * 程序开始执行。调用 main 函数。
 * 
 * 开始执行代码。程序将使用一个运行时堆栈，存储函数的局部变量和返回地址。
 * 静态变量存储在静态内存，整个程序周期都存在
 * 
 * 终止程序。main 函数正常终止，也可能是意外终止。
 */

// 下面详细研究预处理
//
