#define _CRT_SECURE_NO_WARNINGS 1

//编程环境
//预处理


#include <stdio.h>

// 编程的翻译环境 和 运行环境

/*
 * C 标准的任何一种实现中，存在两个不同的环境：
 * 翻译环境和运行环境
 * 
 * test.c 源文件经过 预处理、编译、汇编和链接 生成可执行程序 test.exe，
 * 这个过程中所依赖的环境，称为翻译环境。
 * 源文件本质上是文本文件，而可执行文件则是二进制文件。
 * 源文件到可执行文件，其实就是把人看得懂的文本文件，
 * 翻译成计算机“看得懂”的二进制文件。
 * 
 * 至于生成的可执行文件如何运行，就要依赖具体计算机的运行环境了。
 * 不同计算机的实现原理都是一样的，都有运算器、存储器等等，
 * 但实现的方式却各有不同，不同的实现对应不同的程序运行环境。
 */

// 我们现在来研究翻译环境，观察源代码是如何转换为可执行的机器指令的。
// 

// 运行第一个程序之前，打开 file explorer 观察项目文件底下的文件
// 运行后，再观察项目文件，会发现底下多了一些文件
// （我的翻译环境为，OS: win11、编辑器：VS、编译器：MSVC）
//

// 简单 C 程序
//int main()
//{
//    int arr[10] = { 0 };
//    int i = 0;
//    for (i = 0; i < 10; i++)
//        arr[i] = i;
//
//    for (i = 0; i < 10; i++)
//        printf("%d ", arr[i]);
//
//    return 0;
//}

// 原本只有 test.c 和一些配置文件，
// 运行后有了 test.exe、test.obj 以及一些杂项文件。
// 这些配置文件和杂项文件不是关键的文件，大部分只是 VS 特有的。
// 我们只研究 test.obj。
// 问题来了，test.obj 究竟是什么，为什么要有这个文件？
//

/*
 * C/C++ 语言中有一个重要思想――分别编译，
 * 指的是若干个源文件可以在不同的时候分别编译，在合适的时候整合在一起。
 * 比如有两个源文件 A 和 B，
 * 文件 A 可以实现文件删除的功能，文件 B 则可以文件找回。
 * 实际开发过程中，编程人员先将文件 A 与 main 函数所在文件分别编译、整合，
 * 把生成的 APP 交付给用户使用。
 * 然后根据用户的反馈，说 APP 中文件删除后不能回复，希望能改进，
 * 再编译文件 B，把编译得到的 B.obj 和 A.obj 
 * 
 */
