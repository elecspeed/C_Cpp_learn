### 章节

> 1. 词法“陷阱”
> 2. 语法“陷阱”
> 3. ***语义“陷阱”***
> 4. 链接
> 5. 对库函数的误用
> 6. 预处理
> 7. 可移植性
> 8. 建议
> 9. 附录

---

### 语义“陷阱”

##### 3.1 指针与数组

数组名是数组首元素地址常量，两个例外：

1. `sizeof(数组名)`计算数组大小，单位是字节。

2. `&数组名`得到数组的地址。

> 注：C 语言的古董版本并没有“数组的地址”这一概念，`&数组名`要么非法，要么等同于数组名。引入这一概念是为了解释多维数组。

另外，`*&数组名`还是数组名，而`&*数组名`只是数组首元素地址，因为`sizeof(*&数组名)`得到数组大小，而`sizeof(&*数组名)`得到指针大小。

任何一个数组下标运算都对应一个指针运算，因此我们可以根据指针的行为来定义数组下标的行为。

同时，**C 语言中只有一维数组**，不过数组中的元素可以是任何类型的对象，当然了，也可以是另外一个数组。这样，模拟出一个物理上线性排列、逻辑上多维度排列的多维数组，就不是不可能的了。

##### 3.2 非数组的指针（略）

##### 3.3数组传参

数组做形参时，会自动地被转换成相应的指针形参。

```C
// 三种函数定义等效
int arr[3];
int func(int arr[3]) { /*...*/ }
int func(int arr[]) { /*...*/ }
int func(int *arr) { /*...*/ }
```

因此，*在函数内部不能求外部数组的大小，只能在传参时把外部数组的大小一起传进来。（字符串除外）*

多维数组的情形：

```C
int arr[3][10];
int func(int arr[3][10]) { /*...*/ }
int func(int arr[][10]) { /*...*/ }
int func(int (*arr)[10]) { /*...*/ }
// 上面三种函数定义等效
// 错误写法
// int func(int arr[][]) { /*...*/ }
```

多维数组做形参，第一个维度可以不写。这是因为 C 语言中其实只有一维数组，数组做形参会被转换为相应的指针形参。上面的`int (*arr)[10]`是`int arr[3][10]`对应的指针形参。

##### 3.4避免“举隅法”（略）

##### 3.5空指针并非空字符串（略）

##### 3.6边界计算与不对称边界

来看一段代码：

```C
int i, a[10];
for(i = 0; i <= 10; ++i)
    a[i] = 0;
```

代码的目的很明确，将数组 a 中的所有元素设为 0，却不想运行时发生了意想不到的bug：代码陷入了死循环！（在不同的 C 编译器下循环的终止条件需要设为`i <= 11`或`i <= 12`甚至更大一些，才能看到效果。并且只有在程序的调试版本才能看到，程序的发行版本会优化掉这个bug）

先解释bug。C 语言中内存分为三个区域：栈区、堆区和静态区：

| 内存分区 |       存储内容       |
| :------: | :------------------: |
|   栈区   | 局部变量、函数调用等 |
|   堆区   |    动态开辟内存等    |
|  静态区  | 全局变量、静态变量等 |

其中栈区数据的存储特点是*先进后出*，即新数据会压在原数据的上面，移除原数据之前要先移除新数据。