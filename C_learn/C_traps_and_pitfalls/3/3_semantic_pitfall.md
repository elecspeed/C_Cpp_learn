## 章节

> 1. 词法“陷阱”
> 2. 语法“陷阱”
> 3. ***语义“陷阱”***
> 4. 链接
> 5. 库函数
> 6. 预处理
> 7. 可移植性
> 8. 建议
> 9. 附录

---

## 语义“陷阱”

#### 3.1 指针与数组

数组名是数组首元素地址常量，两个例外：

1. `sizeof(数组名)`计算数组大小，单位是字节。

2. `&数组名`得到数组的地址。

> 注：C 语言的古董版本并没有“数组的地址”这一概念，`&数组名`要么非法，要么等同于数组名。引入这一概念是为了解释多维数组。

另外，`*&数组名`还是数组名，而`&*数组名`只是数组首元素地址，因为`sizeof(*&数组名)`得到数组大小，而`sizeof(&*数组名)`得到指针大小。

任何一个数组下标运算都对应一个指针运算，因此我们可以根据指针的行为来定义数组下标的行为。

同时，**C 语言中只有一维数组**，不过数组中的元素可以是任何类型的对象，当然了，也可以是另外一个数组。这样，模拟出一个物理上线性排列、逻辑上多维度排列的多维数组，就不是不可能的了。

#### 3.2 非数组的指针（略）

#### 3.3 数组传参

数组做形参时，会自动地被转换成相应的指针形参。

```C
// 三种函数定义等效
int arr[3];
int func(int arr[3]) { /*...*/ }
int func(int arr[]) { /*...*/ }
int func(int *arr) { /*...*/ }
```

因此，*在函数内部不能求外部数组的大小，只能在传参时把外部数组的大小一起传进来。（字符串除外）*

多维数组的情形：

```C
int arr[3][10];
int func(int arr[3][10]) { /*...*/ }
int func(int arr[][10]) { /*...*/ }
int func(int (*arr)[10]) { /*...*/ }
// 上面三种函数定义等效
// 错误写法
// int func(int arr[][]) { /*...*/ }
```

多维数组做形参，第一个维度可以不写。这是因为 C 语言中其实只有一维数组，数组做形参会被转换为相应的指针形参。上面的`int (*arr)[10]`是`int arr[3][10]`对应的指针形参。

#### 3.4 避免“举隅法”（略）

#### 3.5 空指针并非空字符串（略）

#### 3.6 边界计算与不对称边界

来看一段代码：

```C
int i, a[10];
for(i = 0; i <= 10; ++i)
    a[i] = 0;
```

代码的目的很明确，将数组 a 中的所有元素设为 0，却不想运行时发生了意想不到的 bug：代码陷入了死循环！（在不同的 C 编译器下循环的终止条件需要设为`i <= 11`或`i <= 12`甚至更大一些，才能看到效果。并且只有在程序的调试版本才能看到，程序的发行版本会优化掉这个bug）

先解释bug。C 语言中内存分为三个区域：栈区、堆区和静态区：

| 内存分区 |       存储内容       |
| :------: | :------------------: |
|   栈区   | 局部变量、函数调用等 |
|   堆区   |    动态开辟内存等    |
|  静态区  | 全局变量、静态变量等 |

其中栈区数据的存储特点是*先进后出*。来看看声明时栈区内存的布局：

<img src="E:\Source\Repos\elecspeed\C_Cpp_learn\C_learn\C_traps_and_pitfalls\3\内存说明.png" alt="栈区变量的地址" style="zoom:50%;" />

*栈区由高地址向低地址为变量分配内存*，新变量会挡在原变量的后面。同时，*数组元素的地址随着下标的增大而增大*。这意味着，数组 a 可以越界访问到变量 i！接下来就发生了刚刚难以理解的 bug。

解释完 bug，再来说说数组下标为什么以 0 开始。伴随数组一起出现的通常是`for`循环，而`for`循环在一开始就要设计起始、终止条件（即左右边界）。常见的边界都是**左闭右开**，即左边可以 <=，右边只能 <。所以用一句话来解释就是，下标以 0 开始，遍历数组就可以这样写：

```C
for(i = 0; i < 数组长度; ++i)
```

读者应该还是觉得不理解：~~这是什么狗屁原因~~。其实，说了这么多，这种左闭右开的不对称边界，以及数组下标以 0 开始的设计，就是为了减少边界计算时可能出现的错误。多敲代码，习惯它。

> 注：数组越界访问是非法的，不论是往前还是往后。C 标准只允许用越界地址来进行赋值和比较，不允许访问。

#### 3.7 求值顺序

C 语言中只有 4 个运算符 （&&、||、?:、,）存在求值顺序。

&& 左边为假则跳过右边；|| 左边为真则跳过右边；?: 和 , 略

> 注：分隔函数实参的逗号不是逗号运算符。表达式 x 和 y 在函数`f(x, y)`中的求值顺序是未定义的。

#### 3.8 运算符 &&、|| 和 !（略，见第一章）

#### 3.9 整数溢出

整数运算中，有无符号整型参与的，没有所谓“溢出”一说。所有无符号运算的结果为

$$
最终结果 = 逻辑结果 \% 2^n
$$

不在 [0, 2^n] 范围内的逻辑结果，通过对 2^n 取模得到最终结果；有符号整数会自动**精度提升**，转换成相应的无符号整数，从而变成无符号运算，结果同上。

当操作数都是有符号整数时，“整数溢出”就有可能发生，而且“溢出”的结果是未定义的。

#### 3.10 为函数 main 提供返回值（略）

> ##### 练习 3_1
>
> 编写一个二分查找函数，输入包括一个指向表头的指针、元素大小、元素个数以及待查找的数值。找到返回对应元素的地址，否则返回NULL。