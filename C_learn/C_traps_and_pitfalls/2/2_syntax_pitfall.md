### 章节
> 1. 词法“陷阱”
> 2. ***语法“陷阱”***
> 3. 语义“陷阱”
> 4. 链接
> 5. 对库函数的误用
> 6. 预处理
> 7. 可移植性
> 8. 建议
> 9. 附录

---

### 语法“陷阱”

##### 2.1 理解函数声明

先来看两个语句：

```C
(*(void(*)())0)(); // ?
void (*signal(int, void(*)(int)))(int); // ?
```

任何 C 变量的声明都由两部分组成：类型以及一组`声明符（declarator）`。例如：

```C
int a, b();
char *c, d[1024];
float *e(), (*f)();
```

其中，e 是一个函数，形参列表为空，返回类型为float指针；f 是一个函数指针（变量），所指函数形参列表为空，所指函数返回类型为float。

我们知道了如何声明一个特定类型的变量，那么，该变量的`类型`就清楚了：把声明中的变量名去掉，剩下的就是变量的类型。（注意不是去掉函数名和数组名！）而一旦知道类型，那么对应的`类型转换符`也就得到了：用一个小括号把类型“封装”起来即可。例如：

```C
float (*h)(); // 声明。表示 h 是一个函数指针（变量），类型为 float(*)()
(float (*)()) // 表示一个函数指针类型的类型转换符
```

OK，现在来看看一开始的那两个语句。

```C
(*(void(*)())0)();
// void(*)() 是一个函数指针类型，加上小括号后，(void(*)()) 成了类型转换符。
// 那么 (void(*)())0 就是将 0 强制类型转换为函数地址。
// 这个语句的意思是：调用首地址为 0 的函数。

void (*signal(int, void(*)(int)))(int);
// 同理可以观察到 void(*)(int) 是一个函数指针类型。
// 这个语句是一个声明，
// 声明 signal 是一个函数，形参为 int, void(*)(int)，返回类型为void(*)(int)
```

第二个语句可能更难理解，问题出在函数的返回类型上。该函数的返回类型竟是函数指针！

可以用`typedef`来简化上面的代码。

```C
typedef void(*func_ptr)();
(*(func_ptr)0)();

typedef void(*FUNC_PTR)(int);
FUNC_PTR signal(int, FUNC_PTR);
```

##### 2.2 运算符的优先级

运算符的优先顺序是由于历史原因形成的。C 语言中运算符的优先级大部分继承了 B 语言。

逗号运算符在宏定义中特别有用。

##### 2.3 注意分号（略）

##### 2.4 switch 语句

遗漏某一个`case`分支后的`break`语句会使程序进入下一个`case`分支，这是其优势所在，也是其弱点。如果确实要这么做，且分支内还有其他语句，建议在`case`最后添加注释。

```C
case '\n':
	linecount++;
	/* 此处没有 break 语句 */
case '\t':
case ' ':
	...
```

上面的代码可能出现在编译器在查找符号时，跳过程序中的空白字符。空格、制表符和换行符的处理都是相同的，不过在跳过换行符时，程序的代码行计数器需要递增。

##### 2.5 函数调用

函数名的本质是函数地址。

##### 2.6 “悬挂”else引发的问题

`else`始终与同一对括号内最近的未匹配的`if`结合。
